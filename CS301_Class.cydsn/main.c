/* ========================================
 * Fully working code
 * Copyright Univ of Auckland, 2016
 * All Rights Reserved
 * UNPUBLISHED, LICENSED SOFTWARE.
 *
 * CONFIDENTIAL AND PROPRIETARY INFORMATION
 * WHICH IS THE PROPERTY OF Univ of Auckland.
 *
 * ========================================

  .oooooo.                              .o8                 oooo                                        .o8  
 d8P'  `Y8b                            "888                 `888                                       "888  
888      888 oooo  oooo  oooo d8b       888oooo.   .ooooo.   888   .ooooo.  oooo    ooo  .ooooo.   .oooo888  
888      888 `888  `888  `888""8P       d88' `88b d88' `88b  888  d88' `88b  `88.  .8'  d88' `88b d88' `888  
888      888  888   888   888           888   888 888ooo888  888  888   888   `88..8'   888ooo888 888   888  
`88b    d88'  888   888   888           888   888 888    .o  888  888   888    `888'    888    .o 888   888  
 `Y8bood8P'   `V88V"V8P' d888b          `Y8bod8P' `Y8bod8P' o888o `Y8bod8P'     `8'     `Y8bod8P' `Y8bod88P"

oooo                          .                                                    
`888                        .o8                                                    
 888   .ooooo.   .ooooo.  .o888oo oooo  oooo  oooo d8b  .ooooo.  oooo d8b  .oooo.o 
 888  d88' `88b d88' `"Y8   888   `888  `888  `888""8P d88' `88b `888""8P d88(  "8 
 888  888ooo888 888         888    888   888   888     888ooo888  888     `"Y88b.  
 888  888    .o 888   .o8   888 .  888   888   888     888    .o  888     o.  )88b 
o888o `Y8bod8P' `Y8bod8P'   "888"  `V88V"V8P' d888b    `Y8bod8P' d888b    8""888P' 

ssssssssssssssssssssssssyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyysyssyyyysssysssssyyyyyyyyyyyyyyyyyyyyyyyyyy
ssssssssssssssssssssssyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyysyyyyyysyyyysssssyyyyyyyyyyyyyyyyyyyyyyyyyyy
sssssssssssssssyyssyyyyyyyyyyyyyyyyyyyyyyyhhyhhhhhhyyyyyyssyssssyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
ssssssssssyyyyyyyyyyyyyyyyyyyyyyyyyyhdhddmNNNNNNNNmmdmmddyyyysssysssssssyyyyyyyyyyyyyyyyyyyyyyyyyyyy
sssssssssyyyyyyyyyyyyyyyyyyyyyyyyhddNNNNmmmhhhddhhhhdmmNNNmdhyyssssssssssyyyyyyyyyyyyyyyyyyyyyyyyyyy
ssssssyyyyyyyyyyyyyyyyyyyyyyyyhdmNmdhhhhyyysoosso+o++ooyyhmNMNNdhhyysssyyyyyyyyyyyyyyyyyyyyyyyyyyyys
ysyyyyyyyyyyyyyyyyyyyyyyyyyyhdmdhysossssooo+//++//////+++osyhmNMMMNmhyyyyyyyyyyyyyyyyyyyyyyyyyyyyysy
syyyyyyyyyyyyyyyyyyyysyyyydmmhsso+++//////::::::::::://////++oshmNMMMNdyyyyyyyyyyyyyyyyyyyyyyyyyyyss
syyyyyyyyyyyyysssssssssyhmmhsoo+///:::::::::---:::::::::://///++osdNMMMmhyyyyyyyyyyyyyyyyyyyyyyyssss
sssssssssssssssssssssyhNNdsoo++///::::-----------------::://///+++ohNMMMNdyyyyyyyyyyyyyyyyyyyyssssss
ssssssssssssssssssssymMNhsoo++///:::--------------------::////////+odNMMMMdyyyyyyyyyyyyyyyyysssyssss
sssssssssssssssssssyNMNhsooo++//:::-------------------::::////////+ohmMMMMMdyyyyyyyyyyyyysysssssssss
sssssssssssssssssshNMNhyssooo+///:::------------------::://///////+oymMMMMMNhyyyyyyyyyssssssssssssss
ssssssssssssssssshNMMmhysssoo+++/::::-----------------::::////////++ymNMMMMMdyyyyyyyyyssssssssssssss
ssssssssssssssssyNMMMdysssssoo++//::::-------------::///+oosssso++++sdNMMMMMNyyyyyssssssssssssssssss
sssssssssssssssydMMMMmhysosooo++////:::---------:/+shmmmNNNNNNNmdhs+osmMMMMMMhyyyyssssssssssssssssss
ssssssssssssssssyNMMMNdysssssyyyhhhhyso/:---::::/oyhmmNNdhhyyhdmmmdyooymMMMMMdyyysssssssssssssssssss
ssssssssssssssssyNMMMMdyyydmNMMMMMMNmdhs+///////+syhhhhysoooossyhhhhyooyNMMMMmyyysssssssssssssssssss
sssssssssssssssyyNMMMNhydNMMNmmdddddddhhyso+///+oyyyyyyyysyysyyyyyysssosdMMMMNyyyyssssssssssssssssyy
ssssssssyssyssyyymMMMNhhNNNmdyyyyyyyhhhhhhyo:--:+sssyyysmdNNyhmdysysosyyhMMMMmsosysssssssssssyyyyyyy
yyyyyysyyyyyyyyyydMMMmhdmmdddddddmddhsyssoys/::/+o+osssosyhhyyhysso+++oosmMNhooyyyyssssssssyyyyyyyyy
yyyyyyyyyyyyyyyyyhMMMmhhhhdmmNNhdNNms+oo/syy+:::+sy+/+oosssssoooso+++++ossmdosyssyyysssyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyNMMNdhyhmhmmmhhdhysoo++hho:--:/+s+//://+++o+++//////+ooosyyo++oyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyymMMMdhsshsyhyyyyyso+/+oss/:---://++//::::::::::::///+osoosys/+syyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyydNMhysssssossoo+++///oss/:---:/::/++//::-----::://+ossoosso//oyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyhdddNhhysoo++////::://o++o//::::/:://++///::::::///++osssosso/:+hyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyhdmhhysoo++///:::://sssyysooosyhhhyyo+++++/////++oooossssys//ohhhyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyydhhhysso+///://+/+shdmmmmddmdhhhys++++oso+/+++ooooossssyyoshhhhhhyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyysshhhdhyyso+++++oo+oosyhddddhhysooo+oooooosso++oooooosssyyyoohhhhhhhyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyysohdddhhhyssoooyyossssssssoooo++++++oosyyysyo++oooooossyyyh++hhhhhhhyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyhysydddhhhhhyysyhyyhhyyyyyyyysyyyhhhhhdddhhyyo++oosoossyyhhdhyhhhhhhhyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyhdyddddhhhhhysoyhdmmNmmddhhysooooossoo++++ssoosyssssyyhhhhdhhhhhhhhhyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyhhhdmmdhhhhdhyoossoosyssssoo++ooo++++++//+oosyhyyyyhhhhhddhhhhhhhhhhhyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyhyshmmddhyyddyoooooooosyyyhhhhyyso+++//++osyhdhhhddddddddhhhdhhhhhhhyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyhhhdmmmmdhhhddysssssssoossyyysso+++//+++osydddhdddddddmdhhhhhhhhhhhyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyhhhhhdmmmmddddddyysssooo+++/////////++oosyhddddddddmmmdhhhhhhhhhhhhyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyhhhhhddmmmmmmdmmdhyssooo++++oo+////+oooshddddmmmmmmmmmdhhhhhhhhhhhhyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyhhhdddmNNNNmmmmmdyysssssossssooosyyhhdddmmmmmmmmmmdhdhhhhhhhhhhhyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyhhhhddddmNNNNNNNNmddhhddhhhdddddddmmmmmmmmmmmmmmmdhyhhhhhhhhhhhyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyhyyyyyyyhhhhhdddddmNNNNNNNNNNNNNNNNNNNNNNNNNNmmmmmmmmmmdhyyyyhhhhhhhhhyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyhhhhhhddddmNNNNNNNNNNNNNNNNNNNNNNNNNNmmmmmmmdhhyyssyoyhhhhhhyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyyyhhhhhhhddmNNNNNNNNNNNNNNNNNNNNNNNNNmmmmmdhhyysssso+oyhhhhyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyyyyyyhhhhhdmmmNNNNNNNNNNNNNNNNNNNNmmmmdddhhysssooss/oooshhyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyhhhhdmmmmmNNNNmmmmmmmmmmmddhhhhhhyyssooooso/+o+oooyysssyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyhhhmdddddmmmddhhhhhhhhhhyyyyysssooooooo+/oooooo+oysoooooossssssssyyy
yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyymddhhhhdddhyyyssyssyyyssssssoo+ooo+++oooooo+++osso+ooooo+oossoooo

yyyyyyyyyyyyyyysyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyysss
yyyyyyyyysyyyyysyyyyyysyyyyyyyyyyyyyyyyyyyyyyyyyhhdddmmmmddhhyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyysyyyyysyyyyyyyyyyyyyyyyyyyhhddmmmNmmmmmNNNNNNNNNNNNNmdhyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyys
syyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyhdmNNNNNNNNNNNNNNNNNNNNNNNNNNNNNdhyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyhdNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNmhyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyyyyyyydNNNNNNNNNNNNNNNNNNNMNNNNNNNNNNNNNNNNNNdyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyyyyyhmNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNdyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyyydmNNNNNNNNMMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNmhyyyyyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyydmNNNNNNNNNNNMNNNNNNNNNNNNNNNNNNNNNNNMNNNNNNNNNNmhyyyyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyydNNNNNNNNNNNNNNNNNNNNNNNNNNmmNmNNNNNNNNNNNNNNNNNNNmdyyyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyhNNNNNNMNNNNNNNNNNNNNNNNmmdddhhhddmmddhdmmNNNNNNNNNNNdyyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyhmNNNNNNNNMNNNNmmmmmdddhyyhyyysyyyyyysssyhhddmmNNNNNNNNdyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyhmNNNNNNNNNNNNNmhhhhhyysoossoooooooooooosssyyyhdmmNNNNNNmhyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyhmNNNNNNNNNNNmmmhyyyyssooooo+++++++++ooooooossyhhddNNNNNNNmhyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyydNNNNNNmmmmmmdhhysssssooo++++/////+++++++oooossyyhhmmNNNNNNdyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyhNNNNNNNNNmmmdhhyysssoooo++//////////++++++oooossyyyddmNNNNNNhyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyydNNNNNNNNNmmddhyyysssooo++++///////////+++++ooosssyyhdmNNNNNNhyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyhNNNNNNNNNNmdhyyysssoooo++++////////////++++ooosssyyhdmNNNNNNhyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyymNNNNNNNNNNmhyyssssooo+++/////////////////++oooossyhdNNNNNNNhyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyhNNNNNNNNNmdhyysssooo++////::::::::::://///+++oossyhdmNNNNNNhyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyhNNNNNNNNmmdhhysssoo++//::-------------::////++oosyyhmNNNNNNhyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyymNNNNNNmmdddhhyssooo+/:::--------------:////+oosyhhhdmNNNNNhyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyhmmNNNNmmmNNNmddhhhdhyys+//::::::::://+osyyyyhhhdmmmddmNdyhyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyhh+dNNNNNNNNmdhhhyyssosoyyooo/////++sossyhddddddmmmNNNNNh+oyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyhoNNNNmmmddddmhhmdmy+sssyyyddhshdhssso/osdmmddddhhmmNdNmooyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyhhNmmmhhhyyhddysddh++ooosyso+//+soyyo++++hdhoodmdyyhhymmdsyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyydymmdhhyyysyhhhhhso+++/oydoo::::+ooys+/+oosyyyhhyyyysohmdyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyydsdmdyysysssssssoo+++++++oo+/://+oo/+o++++oooossssysoshhsyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyhhdmdhhysoooooo+++/////++oo+////++o++//+++++++oooooosydhyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyddmdhhssoo+++++///:::/++o++/////++o++////////++++oosyhhyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyddmmdyysoo++//////:::/o+o+//::://++o+/::://///+++oosyhhsyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyhdmmdhysoo++////::///+++++/:---://++++/::://///++ooshhyyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyhmddysso++///::///+o++++/:-..-:/++++//://////++osyhhyyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyydmdhysoo++///////+o+++o+///::/+++++/////////++oshdhyyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyyhmdhyssoo++//////+++++/////:://++++///////+++osyhdyyyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyyydmhyyssoo++++/+++o++++/::::://++++++++++++oosyhddhyyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyyyhmdhyyssoooo+++ooo++++////////+++ooo++ooo+oosydmNmdhhhyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyydmNNdyyyssoooooossyssooo++//++oosssssoooooossyhdNmNNNmmmddhhyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyhddmNNNNNdhyyysoooo+oossoo+++///++oossysoooooosyyhdmNNNNNNNNmmmmdddhhyyyyyyyyyyy
yyyyyyyyyyyyyyyyyhhdmmmNNNNNNNdhhyysooooooooo+++/////++oossoooooosyyhdNNmNmNNNNNNmNNNNmmmmddhhhyyyyy
yyyyyyyyyyyyyyyhdmmNNNNNNmNNNNNmhhhysssoooooo++++++++++ooosoossssyyhdmNNNmNmNNNNNNNNNNNNNNNNNmmmddhh
yyyyyyyyyyhhdmmmmmNNNNNmNmNmNNNNmddhyyssooooo+++++++++++oooosssyyhhdmNNNNmNmNNNNNNmNmNNNmNNNNNNNNNNN
yyyyyhhhdmmmmmmNNNNNNNmNNmNmNNNNNNmdhhyssoo++++++///++++++ossyyhhdddmNNmNNmNmNmNmNNNNNNNNNNNNNNNNNNN
yyhddmmmmmNmNNNNmNNNmNmNNmNmNmNNmmNNmdhyyso++++///////+++ossyhhdddddNmNmNNmNmmNmmNNNNmNmNNNNmNNNNNNN
dmmmmNNNNmNmNmNNNNNNmNmNmmNmNmNNmddmNNmdhysoo++//////++oosyhddddhhhdNmNNmNNmNmNmNmNNNmNNmNNNNNNNNNNN
NmNNmNmNNNNmmmNNNNNNNNmNmNNNNdmNmmhhhdmNmddysoo+++++ooosyhdddhhyyyyhNNNNmNNmNmmmmmNmNmmNmNNmNmNNNNmN
NmNNNNmNmNNmdmNmNNNmNmmNmNNNNmmNmNmhhyyhdmmmmdhhyyhhhdddddhhyyssyyydNNNNmmNmmNdNdNdNmmmNmmNmNNNNmNmN
NmNmNmNNmNNNmNNmNmNmNmmNmNmNNmmNmmNdhyyyyyyhdddddddddhhhyyssssssssymmNNNmmNNdNdNdNmmmNNNNmNmNNNNmNNN
mNNmNmNNmNmNmNNmNmNmNdNNmNmNNmmNNmNmmhhyssssssssssyyssssssssssssssdNmNmNNmmNdmdmmdNdNmNNNmNNNNNNNNNm
mNmNNmNmNNmNmNNNNmNmNmNmmNmNmmNNNmNmNmhyyyysssossssssssssosososshdmNNNmNNNmNmmNdNdNmmmNNNmNNNNmNNNNN
mNmNNmNmNNmNmNNNNNmmNdNmmNmNmmNmNmNmNNmdhyyyssssssssssoooooooshmmNmNNNmNmNNNNNNNNNNNmNNNNmNNmNNNNNNm
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <project.h>
#include <math.h>
#include "map.h"
#include "defines.h"
#include "vars.h"

#define TAIL 101
#define The_INFINITY 9999
#define MAXMAP_ROWS 15
#define MAXMAP_COLS 19
#define ARRAY_SIZE 300
#define WALKABLE 0

#define TOP_LEFT ADC_0
#define TOP_MIDDLE ADC_2
#define TOP_RIGHT ADC_4
#define BOTTOM_LEFT ADC_1
#define BOTTOM_MIDDLE ADC_3
#define BOTTOM_RIGHT ADC_5

//* ========================================WheelSpeed Functions
int RFround(int16 RFvalue);
//* ========================================WheelSpeed flags
int printingFlag = 0;
//* ========================================ADC Functions
double calculateADC(int ADC);
//* ========================================ADC Flags
// Higher timeout value = lower sensitivity (will correct itself less often)
int timeout = 10;

int ADC_0 = 0;
int adc0_count = 0;
int ADC_1 = 0;
int adc1_count = 0;
int ADC_2 = 0;
int adc2_count = 0;
int ADC_3 = 0;
int adc3_count = 0;
int ADC_4 = 0;
int adc4_count = 0;
int ADC_5 = 0;
int adc5_count = 0;
//* ========================================RF
void Receive_Data(uint8 c);
int16 concatenate(int16 a,uint8 c);
int has_received = 0;
int start_receiving = 0;
int end_receiving = 0;
int analysing = 0;
//int i = 0;
int path_i = 0;
int commaCount=0;
int negative = FALSE;
int test =0;
vtype1 RFdata;
vtype1 clearedRF = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
//* ========================================Pathfinding and other stuff
int currentRForient = 0;
int turnDone_delay = 0;
int off_track = 0;
int off_track_counter = 0;
int front_detected = 0;
int free_to_detect_front = 1;





/************************* Declarations for Pathfinding C *************************/
typedef struct MAP {
	int map[15][19];
} MAP;

// Defines the Node structure. Chars because they're tiny.
typedef struct Node {
	char row;
	char col;
} Node;

// To find neighbours of a Node.
typedef struct NodeList {
	Node foundneighbours[4];
	char lastindex;
} NodeList;

typedef struct NodeMAP {
	Node map[15][19];
} NodeMAP;

// Global Variables
Node PathArray[ARRAY_SIZE];
Node FinalArray[500];
Node NewNodes[ARRAY_SIZE];
Node OldNodes[ARRAY_SIZE];
Node neighbours[4] = { {TAIL,TAIL},{TAIL,TAIL},{TAIL,TAIL},{TAIL,TAIL} };

char visited[MAXMAP_ROWS][MAXMAP_COLS];
char newNodes[MAXMAP_ROWS][MAXMAP_COLS];
MAP DistBefore;
MAP TotalDist;
NodeMAP CameFrom;
int tentativeDist;

// Functions
void push(Node p, Node Array[]);
void listNeighbours(Node val);
int hCost(Node current, Node target);
Node findCurrentNode(Node Array[], MAP map);
void deleteNode(Node p, Node Array[]);
int existInList(Node p, Node Array[]);
void TidyUpThePath(Node Start, Node Pizza);
void astar();
void astar_and_append();

char START_ROW = 0;
char START_COL = 0;
char PIZZA_ROW = 0;
char PIZZA_COL = 0;
int next_free_index = 0;

char food_states[MAXMAP_ROWS][MAXMAP_COLS];
void findNearestFood();
int foodLeft();





/************************* Declarations for Final Maze Navigation *************************/
#define RIGHT 1
#define LEFT 2
#define UP 3
#define DOWN 4
int turnDone = 0;
int turnDone_180 = 0;
int orientation = 0;
int path_index = 0;
int duplicateFlag = 0;
int almost_180=0;
Node currentRFpos;
Node previous;

void useRF();
void Straight();
int nextNodeDirection(int i);





/*
ooooo  .oooooo..o ooooooooo.   
`888' d8P'    `Y8 `888   `Y88. 
 888  Y88bo.       888   .d88' 
 888   `"Y8888o.   888ooo88P'  
 888       `"Y88b  888`88b.    
 888  oo     .d8P  888  `88b.  
o888o 8""88888P'  o888o  o888o
*/

CY_ISR_PROTO(test_isr);
CY_ISR_PROTO(check);
CY_ISR_PROTO(printing);

// For speed correction, 50ms timer is best. For ADC reading, 500ms. LED will show you current value.
CY_ISR(check) {
    Timer_1_ReadStatusRegister();
     /*-----------------------------------------*/
    if (calculateADC(0) > 1.0) {
        ADC_0 = 1;
        adc0_count = 0;
    }
    else{
        adc0_count++;
    }
    if (adc0_count > timeout){
        ADC_0 = 0;
        adc0_count = 0;
    }
   /*-----------------------------------------*/
        if (calculateADC(1) > 1.0) {
        ADC_1 = 1;
        adc1_count = 0;
    }
    else{
        adc1_count++;
    }
    if (adc1_count > timeout){
        ADC_1 = 0;
        adc1_count = 0;
    }
   /*-----------------------------------------*/
        if (calculateADC(2) > 1.0) {
        ADC_2 = 1;
        adc2_count = 0;
    }
    else{
        adc2_count++;
    }
    if (adc2_count > timeout){
        ADC_2 = 0;
        adc2_count = 0;
    }
   /*-----------------------------------------*/
        if (calculateADC(3) > 1.0) {
        ADC_3 = 1;
        adc3_count = 0;
    }
    else{
        adc3_count++;
    }
    if (adc3_count > timeout){
        ADC_3 = 0;
        adc3_count = 0;
    }
   /*-----------------------------------------*/
        if (calculateADC(4) > 1.0) {
        ADC_4 = 1;
        adc4_count = 0;
    }
    else{
        adc4_count++;
    }
    if (adc4_count > timeout){
        ADC_4 = 0;
        adc4_count = 0;
    }
   /*-----------------------------------------*/
        if (calculateADC(5) > 1.0) {
        ADC_5 = 1;
        adc5_count = 0;
    }
    else{
        adc5_count++;
    }
    if (adc5_count > timeout){
        ADC_5 = 0;
        adc5_count = 0;
    }
   /*-----------------------------------------*/
    
    if (TOP_LEFT == 1 && TOP_MIDDLE == 1 && TOP_RIGHT == 1 && BOTTOM_LEFT == 1 && BOTTOM_MIDDLE == 1 && BOTTOM_RIGHT == 1) {
        ++off_track_counter;
        if (off_track_counter == 50) {
            off_track = 1;
            off_track_counter = 0;
        }
    }
    
    else if (orientation == RIGHT) {
        if (nextNodeDirection(path_index) == UP && BOTTOM_LEFT == 0) {
            off_track = 0;
            off_track_counter = 0;
        }
        else if (nextNodeDirection(path_index) == DOWN && BOTTOM_RIGHT == 0) {
            off_track = 0;
            off_track_counter = 0;
        }
        else if (nextNodeDirection(path_index) == RIGHT || nextNodeDirection(path_index) == LEFT) {
            off_track = 0;
            off_track_counter = 0;
        }
    }
    
    else if (orientation == LEFT) {
        if (nextNodeDirection(path_index) == UP && BOTTOM_RIGHT == 0) {
            off_track = 0;
            off_track_counter = 0;
        }
        else if (nextNodeDirection(path_index) == DOWN && BOTTOM_LEFT == 0) {
            off_track = 0;
            off_track_counter = 0;
        }
        else if (nextNodeDirection(path_index) == RIGHT || nextNodeDirection(path_index) == LEFT) {
            off_track = 0;
            off_track_counter = 0;
        }
    }
    
    else if (orientation == UP) {
        if (nextNodeDirection(path_index) == RIGHT && BOTTOM_RIGHT == 0) {
            off_track = 0;
            off_track_counter = 0;
        }
        else if (nextNodeDirection(path_index) == LEFT && BOTTOM_LEFT == 0) {
            off_track = 0;
            off_track_counter = 0;
        }
        else if (nextNodeDirection(path_index) == UP || nextNodeDirection(path_index) == DOWN) {
            off_track = 0;
            off_track_counter = 0;
        }
    }
    
    else if (orientation == DOWN) {
        if (nextNodeDirection(path_index) == RIGHT && BOTTOM_LEFT == 0) {
            off_track = 0;
            off_track_counter = 0;
        }
        else if (nextNodeDirection(path_index) == LEFT && BOTTOM_RIGHT == 0) {
            off_track = 0;
            off_track_counter = 0;
        }
        else if (nextNodeDirection(path_index) == UP || nextNodeDirection(path_index) == DOWN) {
            off_track = 0;
            off_track_counter = 0;
        }
    }
}

CY_ISR(printing) {
    
    printingFlag = 1;
    Timer_2_ReadStatusRegister();
    
    if (turnDone == 1) {
        ++turnDone_delay;
    }
    
    if (turnDone_delay == 3) {
        // After completing a turn, you can turn again only after getting out of the intersection.
        if (BOTTOM_LEFT == 1 && BOTTOM_RIGHT == 1) {
            turnDone = 0;
        }
        turnDone_delay = 0;
    }
}

#define RECEIVING start_receiving &&(!end_receiving)

CY_ISR(test_isr){
    
    uint8 character = UART_GetChar();
    if (character =='#'){
        vtype1 a={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
        RFdata = a;
        start_receiving = TRUE;
        end_receiving = FALSE;
        commaCount=0;
         test++;
    }else if ( character == '\n'){
         end_receiving  = TRUE;
         start_receiving = FALSE;
        
        // Gets RF information as soon as it's available.
        currentRFpos.row = RFround(RFdata.robot_ypos);
        currentRFpos.col = RFround(RFdata.robot_xpos);
        currentRForient = RFdata.robot_orientation/10;
        
        // Fixes some 180 bugs.
        if (orientation == RIGHT && currentRForient >= 0 && currentRForient <= 90) {
            currentRForient += 360;
        }
        else if (orientation == UP && currentRForient >= 0 && currentRForient <= 180) {
            currentRForient += 360;
        }
         
    }else if ( character == ','){
        commaCount= commaCount+1;
    }else if (character == '-'){
        negative = TRUE;
    }else if (character == ']'||character == '['){

    }else {
        if (RECEIVING) Receive_Data(character);
}
}





/*
ooooo     ooo       .o.       ooooooooo.   ooooooooooooo  .oooooo..o 
`888'     `8'      .888.      `888   `Y88. 8'   888   `8 d8P'    `Y8 
 888       8      .8"888.      888   .d88'      888      Y88bo.      
 888       8     .8' `888.     888ooo88P'       888       `"Y8888o.  
 888       8    .88ooo8888.    888`88b.         888           `"Y88b 
 `88.    .8'   .8'     `888.   888  `88b.       888      oo     .d8P 
   `YbodP'    o88o     o8888o o888o  o888o     o888o     8""88888P' 
*/

void Receive_Data(uint8 c){
    switch (commaCount){
        case 0 :
            RFdata.rssi = concatenate(RFdata.rssi, c-48);
        break;
        case 1 :
            RFdata.index = concatenate(RFdata.index, c-48);
        break;
        case 2 :
            RFdata.robot_xpos = concatenate(RFdata.robot_xpos, c-48);
        break;
        case 3 :
            RFdata.robot_ypos = concatenate(RFdata.robot_ypos, c-48);
        break;
        case 4 :
            RFdata.robot_orientation = concatenate(RFdata.robot_orientation, c-48);
        break;
        case 5 :
            RFdata.g0_xpos = concatenate(RFdata.g0_xpos, c-48);
        break;
        case 6 :
            RFdata.g0_ypos = concatenate(RFdata.g0_ypos, c-48);
        break;
        case 7 :
            RFdata.g0_speed = concatenate(RFdata.g0_speed, c-48);
        break;
        case 8 :
            RFdata.g0_direction = concatenate(RFdata.g0_direction, c-48);
        break;
        case 9 :
            RFdata.g1_xpos = concatenate(RFdata.g1_xpos, c-48);
        break;
        case 10 :
            RFdata.g1_ypos = concatenate(RFdata.g1_ypos, c-48);
        break;
        case 11 :
            RFdata.g1_speed = concatenate(RFdata.g1_speed, c-48);
        break;
        case 12 :
            RFdata.g1_direction = concatenate(RFdata.g1_direction, c-48);
        break;
        case 13 :
            RFdata.g2_xpos = concatenate(RFdata.g2_xpos, c-48);
        break;
        case 14 :
            RFdata.g2_ypos = concatenate(RFdata.g2_ypos, c-48);
        break;
        case 15 :
            RFdata.g2_speed = concatenate(RFdata.g2_speed, c-48);
        break;
        case 16 :
            RFdata.g2_direction = concatenate(RFdata.g2_direction, c-48);
        break;
        default:
        return;
    }
}

int16 concatenate(int16 a,uint8 b){
    if(negative){
        negative = FALSE;  
        a = -b;
    }
    else if(a<0){
        a = a*10-b;   
    }
    else{
        a = a*10+b;
    }
    return a;
}





/*
  .oooooo.       .   oooo                                    
 d8P'  `Y8b    .o8   `888                                    
888      888 .o888oo  888 .oo.    .ooooo.  oooo d8b  .oooo.o 
888      888   888    888P"Y88b  d88' `88b `888""8P d88(  "8 
888      888   888    888   888  888ooo888  888     `"Y88b.  
`88b    d88'   888 .  888   888  888    .o  888     o.  )88b 
 `Y8bood8P'    "888" o888o o888o `Y8bod8P' d888b    8""888P'
*/

double calculateADC(int ADC) {
    
    // Variable Initialisations
    double TL = ADC_CountsTo_Volts(ADC_GetResult16(ADC));   // Any ADC value
    
    return TL;
}





/*
      .o.        .oooooo..o ooooooooooooo       .o.       ooooooooo.   
     .888.      d8P'    `Y8 8'   888   `8      .888.      `888   `Y88. 
    .8"888.     Y88bo.           888          .8"888.      888   .d88' 
   .8' `888.     `"Y8888o.       888         .8' `888.     888ooo88P'  
  .88ooo8888.        `"Y88b      888        .88ooo8888.    888`88b.    
 .8'     `888.  oo     .d8P      888       .8'     `888.   888  `88b.  
o88o     o8888o 8""88888P'      o888o     o88o     o8888o o888o  o888o 
*/

void astar() {

	Node TailNode;
	TailNode.row = TAIL;
	TailNode.col = TAIL;

	push(TailNode, PathArray);
	push(TailNode, NewNodes);
	push(TailNode, OldNodes);
    
    Node Start;
	Start.row = START_ROW;
	Start.col = START_COL;
    push(Start,NewNodes);
    Node Pizza;
	Pizza.row = PIZZA_ROW;
	Pizza.col = PIZZA_COL;

	int row = sizeof(map) / sizeof(map[0]);
	int col = sizeof(map[0]) / sizeof(map[0][0]);

	//initialize the DistBefore array
	for (int i = 0; i < row; i++) {
		for (int j = 0; j < col; j++) {
			DistBefore.map[i][j] = The_INFINITY;
		}
	}
	DistBefore.map[Start.row][Start.col] = 0;

	TotalDist = DistBefore;
	TotalDist.map[Start.row][Start.col] = hCost(Start, Pizza);

	// Executes
	Node Current;
	int indexN = 0;
    
	while (NewNodes[0].row != TAIL) {
		Current = findCurrentNode(NewNodes, TotalDist);
		if (Current.row == Pizza.row && Current.col == Pizza.col) {
			TidyUpThePath(Start, Pizza);
			return;
		}
		else {
			deleteNode(Current, NewNodes);
			push(Current, OldNodes);
			listNeighbours(Current);
			for (int i = 0; i < 4; i++) {
				if (neighbours[i].row == TAIL) {
					break;
				}
				if (existInList(neighbours[i], OldNodes)) {
					continue;
				}
				else {
					push(neighbours[i], NewNodes);
				}
				tentativeDist = DistBefore.map[Current.row][Current.col] + hCost(Current, neighbours[i]);
				if (tentativeDist >= DistBefore.map[neighbours[i].row][neighbours[i].col]) {
					continue;
				}
				CameFrom.map[neighbours[i].row][neighbours[i].col].row = Current.row;
				CameFrom.map[neighbours[i].row][neighbours[i].col].col = Current.col;
				DistBefore.map[neighbours[i].row][neighbours[i].col] = tentativeDist;
				TotalDist.map[neighbours[i].row][neighbours[i].col] = DistBefore.map[neighbours[i].row][neighbours[i].col]
					+ hCost(neighbours[i], Pizza);
			}
		}
	}
	return;
}

void TidyUpThePath(Node Start, Node Pizza) {
	int NextRow = CameFrom.map[Pizza.row][Pizza.col].row;
	int NextCol = CameFrom.map[Pizza.row][Pizza.col].col;
	Node temp;
	temp.row = Pizza.row;
	temp.col = Pizza.col;
	push(temp, PathArray);
	temp.row = NextRow;
	temp.col = NextCol;
	while (NextRow != Start.row || NextCol != Start.col) {
		temp.row = NextRow;
		temp.col = NextCol;
		push(temp, PathArray);
		NextRow = CameFrom.map[temp.row][temp.col].row;
		NextCol = CameFrom.map[temp.row][temp.col].col;
	}
	temp.row = NextRow;
	temp.col = NextCol;
	push(temp, PathArray);
}

Node findCurrentNode(Node Array[], MAP Map) {
	int i = 0;
	int shortest = The_INFINITY;
	Node N;
	for (int i = 0; i < ARRAY_SIZE; ++i) {
		if (Map.map[Array[i].row][Array[i].col] < shortest) {
			shortest = Map.map[Array[i].row][Array[i].col];
			N.row = Array[i].row;
			N.col = Array[i].col;
		}
		if (Array[i + 1].row == TAIL) {
			break;
		}
	}
	return N;
}

void listNeighbours(Node val) {
	NodeList  listNeighbours = { {{0}},0 };
	int arrayindex = 0;

	int direction[4][2] = { {1,0},
						   {0,1},
						   {-1,0},
						   {0,-1} };
	for (int r = 0; r < 4; r++) {
		//test if direction is out of the map range 
		if (direction[r][0] != 0) {
			if ((direction[r][0] + val.row <= MAXMAP_ROWS) && (direction[r][0] + val.row) >= 0) {
				Node storeval = { (char)(direction[r][0] + val.row),(char)val.col };
				if (map[storeval.row][storeval.col] == WALKABLE) {
					neighbours[arrayindex] = storeval;
					arrayindex++;
				}
			}
		}

		if (direction[r][1] != 0) {
			if ((direction[r][1] + val.col <= MAXMAP_COLS) && (direction[r][1] + val.col) >= 0) {
				Node storeval = { (char)val.row,(char)(direction[r][1] + val.col) };
				if (map[storeval.row][storeval.col] == WALKABLE) {
					neighbours[arrayindex] = storeval;
					arrayindex++;
				}
			}
		}
	}
}

int hCost(Node current, Node target) {
	return sqrt((current.row - target.row)*(current.row - target.row) + (current.col - target.col)*(current.col - target.col));
}

void push(Node p, Node Array[]) {

	for (int i = ARRAY_SIZE - 1; i > 0; --i) {

		Array[i] = Array[i - 1];
	}

	Array[0] = p;
}

void deleteNode(Node p, Node Array[]) {
	int f = 0;
	for (int i = 0; i < ARRAY_SIZE - 1; ++i) {
		if (p.row == Array[i].row && p.col == Array[i].col) {
			f = 1;
		}
		if (f == 1) {
			Array[i] = Array[i + 1];
		}

	}
	Array[ARRAY_SIZE - 1] = (Node) { TAIL, TAIL };
}

int existInList(Node p, Node Array[]) {
	for (int i = 0; i < ARRAY_SIZE - 1; ++i) {
		if (p.row == Array[i].row && p.col == Array[i].col) {
			return 1;
		}
	}
	return 0;
}

void astar_and_append() {
    
    // Executes ASTAR.
	astar();
    
    // Finds the next free index in the final path array.
    for (int i = 0; i < 500; ++i) {
        if (FinalArray[i].row == TAIL) {
            next_free_index = i;
            break;
        }
    }
    
    // Chucks the generated path into the final path array.
    for (int i = 0; PathArray[i].row != TAIL; ++i) {
        FinalArray[next_free_index] = PathArray[i+1];
        ++next_free_index;
    }
    
    // Any food along this generated path has been eaten.
    for (int i = 0; PathArray[i].row != TAIL; ++i) {
        food_states[PathArray[i].row][PathArray[i].col] = 1;
    }
    
    // Flushes all the arrays.
    for (int i = 0; i < ARRAY_SIZE; ++i) {
        PathArray[i].row = TAIL;
        PathArray[i].col = TAIL;
        NewNodes[i].row = TAIL;
        NewNodes[i].col = TAIL;
        OldNodes[i].row = TAIL;
        OldNodes[i].col = TAIL;
    }
    
    for (int i = 0; i < MAXMAP_ROWS; ++i) {
        for (int j = 0; j < MAXMAP_COLS; ++j) {
            visited[i][j] = 0;
            newNodes[i][j] = 0;
        }
    }
    
    Node TailNode;
    TailNode.row = TAIL;
    TailNode.col = TAIL;
    
    for (int i = 0; i < 4; ++i) {
        neighbours[i] = TailNode;
    }
    
    // We are now at pizza.
    START_ROW = PIZZA_ROW;
    START_COL = PIZZA_COL;
}

void findNearestFood() {

    double closest_dist = 999.0;
    
    // Our current location's food is eaten.
    food_states[START_ROW][START_COL] = 1;
    
    for (int i = 0; i < MAXMAP_ROWS; ++i) {
        for (int j = 0; j < MAXMAP_COLS; ++j) {
            if (food_states[i][j] == 0) {
                
                // Gets the distance to this new food.
                double distance = sqrt(pow((START_ROW - i),2) + pow((START_COL - j),2));
                
                // Always gets the closest food.
                if (distance < closest_dist) {
                    closest_dist = distance;
                    PIZZA_ROW = i;
                    PIZZA_COL = j;
                }
            }
        }
    }
}

int foodLeft() {
    
    int counter = 0;
    
    for (int i = 0; i < MAXMAP_ROWS; ++i) {
        for (int j = 0; j < MAXMAP_COLS; ++j) {
            if (food_states[i][j] == 0) {
                ++counter;
            }
        }
    }
    
    return counter;
}

/************************* Find the direction of the next node. *************************/
int nextNodeDirection(int i) {
    if (FinalArray[i+1].col - FinalArray[i].col == 1) {
        return RIGHT;
    }
    else if (FinalArray[i].col - FinalArray[i+1].col == 1) {
        return LEFT;
    }
    else if (FinalArray[i].row - FinalArray[i+1].row == 1) {
        return UP;
    }
    else if (FinalArray[i+1].row - FinalArray[i].row == 1) {
        return DOWN;
    }
    return 0;
}

/************************* FINAL MAZE NAVIGATION FUNCTIONS *************************/
void turn(int direction) {
    
    COAST_ON;
    CyDelay(250);
    COAST_OFF;
    
    // If there was a path in front of the robot, ignore it.
    // The front sensor has to be in the light before it detect dark again
    if (TOP_MIDDLE == 0 || TOP_LEFT == 0 || TOP_RIGHT == 0) {
        free_to_detect_front = 0;
    }
    else {
        free_to_detect_front = 1;
    }
    
    // If we want to turn left or right...
    if (direction == LEFT || direction == RIGHT) {
        //turn and hold its position
        PWM_1_WriteCompare(80);
        PWM_2_WriteCompare(80);
        Direction_Control_1_Write(direction);
        Direction_Control_2_Write(direction);
        
        while (front_detected != 1) {
        
            if (TOP_MIDDLE == 1 && TOP_LEFT == 1 && TOP_RIGHT == 1) {
                free_to_detect_front = 1;
            }
            
            if (TOP_MIDDLE == 0 && free_to_detect_front == 1) {
                free_to_detect_front = 0;
                ++front_detected;
            }
        }
        front_detected = 0;
        free_to_detect_front = 1;
    }
    
    // If we want to reverse...
    else if (direction == 180) {
        PWM_1_WriteCompare(80);
        PWM_2_WriteCompare(80);
        Direction_Control_1_Write(1);
        Direction_Control_2_Write(1);
        
        // Find how many neighbours we have.
       // PathNodeList reversing = listNeighbours(currentRFpos);
        int angle = 180+(currentRForient);
        angle += 40;
        
        if(angle>360) angle -=360; 
        while((currentRForient) > angle){
            LED_ON;
        }
        LED_OFF;
        while (!almost_180) {
            if (TOP_MIDDLE == 0) {
                almost_180=1;
            }
        }
        almost_180 = 0;
        front_detected = 0;
        free_to_detect_front = 1;
    }
  
    //Go straight
    Straight();
    Direction_Control_1_Write(1);
    Direction_Control_2_Write(2);
    turnDone = 1;
    turnDone_180 = 1;
    LED_1_OFF;
    LED_2_OFF;
}

/************************* BUILT-IN ROUNDING BECAUSE C'S DOESN'T WORK! WE ALSO CONVERT IT TO APPROPRIATE COORDINATES! *************************/
int RFround(int16 RFvalue) {
    
    // Take the coordinate, divide it by the divider.
    double rf_d = (double)(RFvalue) / 55.0;             // It's 55, because distance between cells was 110 pixels, divided by 2 because of map scale.
    
    // Multiply the double by 10 to get an integer.
    int rf_i = (int)(rf_d * 10);
    
    // Find the remainder.
    int mod = rf_i % 10;
    
    // If remainder <= 4, truncate, else round up.
    int rf;
    if (mod <= 4) {
        rf = rf_i / 10;
    }
    else {
        rf = (rf_i / 10) + 1;
    }
    
    return rf;
}

void Straight() {
    if (TOP_RIGHT == 0) {
        PWM_1_WriteCompare(80);
        PWM_2_WriteCompare(55);
    }
    
    // Towards left correction
    else if (TOP_LEFT == 0) {
        PWM_1_WriteCompare(55);
        PWM_2_WriteCompare(80);
    }
    
    else {
        PWM_1_WriteCompare(90);
        PWM_2_WriteCompare(90);
    }
}

/************************* Chooses a path to take based on RF. *************************/
void useRF() {

    // If our next PathNode is to the right...
    if (nextNodeDirection(path_index) == RIGHT) {
        if (orientation == LEFT && turnDone_180 == 0) {
            LED_1_ON;
            turn(180);
        }
        else if (orientation == UP && (BOTTOM_RIGHT == 0) && turnDone == 0) {
            LED_2_ON;
            turn(RIGHT);
        }
        else if (orientation == DOWN && (BOTTOM_LEFT == 0) && turnDone == 0) {
            LED_2_ON;
            turn(LEFT);
        }
        else {
            Straight();
        }
    }
    
    // If our next PathNode is to the left...
    else if (nextNodeDirection(path_index) == LEFT) {
        if (orientation == RIGHT && turnDone_180 == 0) {
            LED_1_ON;
            turn(180);
        }
        else if (orientation == UP && (BOTTOM_LEFT == 0) && turnDone == 0) {
            LED_2_ON;
            turn(LEFT);
        }
        else if (orientation == DOWN && (BOTTOM_RIGHT == 0) && turnDone == 0) {
            LED_2_ON;
            turn(RIGHT);
        }
        else {
            Straight();
        }
    }
    
    // If our next PathNode is to the top...
    else if (nextNodeDirection(path_index) == UP) {
        if (orientation == LEFT && (BOTTOM_RIGHT == 0) && turnDone == 0) {
            LED_2_ON;
            turn(RIGHT);
        }
        else if (orientation == RIGHT && (BOTTOM_LEFT == 0) && turnDone == 0) {
            LED_2_ON;
            turn(LEFT);
        }
        else if (orientation == DOWN && turnDone_180 == 0) {
            LED_1_ON;
            turn(180);
        }
        else {
            Straight();
        }
    }
    
    // If our next PathNode is to the bottom...
    else if (nextNodeDirection(path_index) == DOWN) {
        if (orientation == LEFT && (BOTTOM_LEFT == 0) && turnDone == 0) {
            LED_2_ON;
            turn(LEFT);
        }
        else if (orientation == RIGHT && (BOTTOM_RIGHT == 0) && turnDone == 0) {
            LED_2_ON;
            turn(RIGHT);
        }
        else if (orientation == UP && turnDone_180 == 0) {
            LED_1_ON;
            turn(180);
        }
        else {
            Straight();
        }
    }
}





/*
ooo        ooooo       .o.       ooooo ooooo      ooo 
`88.       .888'      .888.      `888' `888b.     `8' 
 888b     d'888      .8"888.      888   8 `88b.    8  
 8 Y88. .P  888     .8' `888.     888   8   `88b.  8  
 8  `888'   888    .88ooo8888.    888   8     `88b.8  
 8    Y     888   .8'     `888.   888   8       `888  
o8o        o888o o88o     o8888o o888o o8o        `8                                       
*/

int main()
{

// --------------------------------
// ----- INITIALIZATIONS ----------
    CYGlobalIntEnable;
    //LED_OFF;
    QuadDec_M1_Start();
    QuadDec_M2_Start();
    PWM_1_Start();
    PWM_2_Start();
    Timer_1_Start();
    Timer_2_Start();
    check_StartEx(check);
    printing_StartEx(printing);
    isrRF_RX_StartEx(test_isr);
    
    // ADC Initialisations
    ADC_Start();
    ADC_StartConvert();
    
    //UART Init
    RF_BT_SELECT_Write(0);
    UART_Start();
    
    // Set the robot's PWM to a value that roughly matches the set speed. (Benchmark 4)
    PWM_1_WriteCompare(80);
    PWM_2_WriteCompare(80);
    
    int m2i = 0;
    
    // Initialises the final path array.
    for (int i = 0; i < 500; ++i) {
        FinalArray[i].row = TAIL;
        FinalArray[i].col = TAIL;
    }
    
    // Initialises the food states array. (It's exactly the same as the map array!)
    for (int i = 0; i < MAXMAP_ROWS; ++i) {
        for (int j = 0; j < MAXMAP_COLS; ++j) {
            food_states[i][j] = map[i][j];
        }
    }
    
    /*
     .oooooo..o     .                          .        ooooo   ooooo                              
    d8P'    `Y8   .o8                        .o8        `888'   `888'                              
    Y88bo.      .o888oo  .oooo.   oooo d8b .o888oo       888     888   .ooooo.  oooo d8b  .ooooo.  
     `"Y8888o.    888   `P  )88b  `888""8P   888         888ooooo888  d88' `88b `888""8P d88' `88b 
         `"Y88b   888    .oP"888   888       888         888     888  888ooo888  888     888ooo888 
    oo     .d8P   888 . d8(  888   888       888 .       888     888  888    .o  888     888    .o 
    8""88888P'    "888" `Y888""8o d888b      "888"      o888o   o888o `Y8bod8P' d888b    `Y8bod8P' 
    */
    
    START_ROW = 1;
    START_COL = 1;
    orientation = DOWN;
    
    FinalArray[next_free_index].row = START_ROW;
    FinalArray[next_free_index].col = START_COL;
    
    // For the final test, Mode 1 or Mode 2...
    if (DIP0_Read() == 0 && DIP1_Read() == 0) {
        while (foodLeft() > 0) {
        findNearestFood();
	    astar_and_append();
        }
    }
    else if (DIP0_Read() == 1 && DIP1_Read() == 0) {
        while (m2i != 6) {
    		PIZZA_ROW = food_list[m2i][1];
    		PIZZA_COL = food_list[m2i][0];
    		astar_and_append();
    		++m2i;
    	}
    }
    
    LED_ON;
    
    //running while loop 
    while (1) {
        
        //get the current position for the first time
        currentRFpos.row = RFround(RFdata.robot_ypos);
        currentRFpos.col = RFround(RFdata.robot_xpos);
        
        while(path_index != ARRAY_SIZE) { //while it is not the last node
            
            //while it has not reach the next node yet
            while(currentRFpos.row != FinalArray[path_index + 1].row || currentRFpos.col != FinalArray[path_index + 1].col) {
                
                duplicateFlag = 0;
                
                if (off_track == 1) {
                    Direction_Control_1_Write(2);
                    Direction_Control_2_Write(1);
                    PWM_1_WriteCompare(60);
                    PWM_2_WriteCompare(60);
                }
                else {
                    // Prioritises using RF over the new turning code.
                    Direction_Control_1_Write(1);
                    Direction_Control_2_Write(2);
                    useRF();
                }
            }
            
            if (duplicateFlag == 0) {
                orientation = nextNodeDirection(path_index);
                ++path_index;
                duplicateFlag = 1;
                turnDone_180 = 0;
            }
            
            // WE ARE DONE!
            if (FinalArray[path_index].row == TAIL && FinalArray[path_index].col == TAIL) {
                Direction_Control_1_Write(1);
                Direction_Control_2_Write(1);
                PWM_1_WriteCompare(255);
                PWM_2_WriteCompare(255);
            }
        }
    }
}
/*[] END OF FILE*/
